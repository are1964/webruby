<!doctype html>
<html>
<head>
<title>Intermediate Ruby</title>
<meta charset="utf-8">
</head>
<body>
<div>
<h2>Course Contents</h2>
<ul>
<li>Using Git
  <ul>
    <li>What's Version Control</li>
    <li>What's Git?
      <ul>
        <li>Downloading and Installing Git</li>
        <li>Create a local folder</li>
        <li>Let us start using Git</li>
        <li>Introduce yourself to Git</li>
        <li>Create your SSH Key</li>
      </ul>
    </li>
  </ul>
</li>
<li>Using GitHub
  <ul>
    <li>What's GitHub?
      <ul>
        <li>Set up your GitHub account</li>
        <li>Creating a new repository</li>
        <li>Add your SSH key to GitHub</li>
      </ul>
    </li>
  </ul>
</li>
<li>Creating a simple webpage using HTML5, CSS and JavaScript
  <ul>
    <li>A Webpage, Step by Step</li>
    <li>Before we begin, Launch a Text Editor
      <ul>
        <li>Step 1: Start with content</li>
        <li>Step 2: Give the document structure</li>
        <li>Step 3: Identify text elements</li>
        <li>Step 4: Add an image</li>
        <li>Step 5: Change the look with a style sheet</li>
        <li>Add some JavaScript</li>
      </ul>
    </li>
  </ul>
</li>
<li>Store your webpage files on GitHub</li>
<li>Understanding HTTP concepts
  <ul>
    <li>What's HTTP?
      <ul>
        <li>Loading a web page</li>
      </ul>
    </li>
    <li>HTTP request methods (verbs)
      <ul>
        <li>GET</li>
        <li>POST</li>
        <li>PUT</li>
        <li>DELETE</li>
      </ul>
    </li>
    <li>HTTP response codes</li>
    <li>net/http library
      <ul>
        <li>Using URI</li>
      </ul>
    </li>
    <li>Using open-uri</li>
    <li>Using Hpricot</li>
  </ul>
</li>
<li>Creating one's own Ruby Gem
  <ul>
    <li>What's a Ruby Gem?</li>
    <li>Let us create a simple Ruby library</li>
    <li>Steps for publishing our gem</li>
  </ul>
</li>
<li>Learning Rack
  <ul>
    <li>What's Rack?</li>
    <li>Rack Documentation</li>
    <li>Installing Rack</li>
    <li>A quick visit to Ruby's proc object</li>
    <li>A simple Rack app - my_rack_proc</li>
    <li>Another Rack app - my_method</li>
    <li>Using rackup</li>
  </ul>
</li>
<li>Deploying Pure Rack Apps to Heroku
  <ul>
    <li>What's Heroku?
      <ul>
        <li>Create an account on Heroku</li>
      </ul>
    </li>
  </ul>
</li>
<li>Deploying a static webpage to Heroku</li>
<li>What's JSON?</li>
<li>Using MongoDB with Ruby Mongo driver
  <ul>
    <li>What's NoSQL?</li>
    <li>What's MongoDB?</li>
    <li>Setup MongoDB</li>
    <li>MongoDB Core Concepts</li>
    <li>The Basics
      <ul>
        <li>Switch databases</li>
		<li>Insert a document</li>
        <li>Use find()</li>
        <li>Removing all documents</li>
        <li>Query Selectors</li>
        <li>Updating a document</li>
      </ul>
    </li>
    <li>MongoDB Ruby Driver - mongo
      <ul>
        <li>Installation</li>
        <li>Using the mongo gem</li>
        <li>Making a Connection</li>
        <li>Getting a List Of Collections</li>
        <li>Getting a Collection</li>
        <li>Inserting a Document</li>
        <li>Updating a Document</li>
      </ul>
    </li>
  </ul>
</li>
<li>Sinatra with MongoDB
  <ul>
    <li>What's Sinatra?</li>
    <li>Create a folder on your hard disk</li>
    <li>Install Sinatra</li>
  </ul>
</li>
<li>References</li>
</ul>

<p>To become a Ruby professional, here are some tools that I suggest you start using as early as possible. Please rest assured that <em>spending time learning these tools is normal and in the end the reward is worth the effort.</em>.</p>

<h2>Using Git</h2>
<p>Here's what a <a href="http://rubylearning.com/blog/2009/01/13/little-known-ways-to-rubymastery-by-thibaut-barrere/">Ruby master</a> says about Git - "A new Ruby programmer should focus on source control - even if you work alone, even for a small "labs" type of applications, use SVN, Git or whatever you feel comfortable with.</p>

<h3>What's Version Control?</h3>
<p><em>Version control</em> also known as source control or source code management or revision control in its simplest form is saving your first draft, and then saving it as draft 2 and continuing on with your editing. This allows you some means of going back to a previous version if you decide that the direction you took in your document is not the direction you want to go, and you want to continue on from where your first draft first was. Version control in a more granular manner is being able to see each change as it was made. In reality, it ends up being likely that you want something between these two extremes.</p>

<p><a href="http://en.wikipedia.org/wiki/Version_control_system#Common_vocabul">Read this</a> for more details.</p>

<h3>What's Git?</h3>
<p>Git is an open source version control system designed to handle very large projects with speed and efficiency, but just as well suited for small personal repositories (collection of resources that can be accessed to retrieve information); it is especially popular in the open source community, serving as a development platform for projects like the Linux Kernel, Ruby on Rails, etc.</p>

<h4>Downloading and Installing Git</h4>
<p>To download and install Git, the precompiled packages are available here: <a href="http://git.or.cz/">http://git.or.cz/</a></p>

<p>Select the relevant package for your operating system.</p>

<p><b>Note:</b> Git still has some issues on the Windows platform but for normal usage the msysgit package shouldn't let you down.</p>
<p>Download and install it from the url: <a href="http://code.google.com/p/msysgit/downloads/list">http://code.google.com/p/msysgit/downloads/list</a> and select the current version available.</p>

<p>Install by running the EXE installer. Accept the default install directory. It is recommended for Windows users to use the "Use Git Bash only" option.</p>

<h4>Create a local folder</h4>

<p>Create a new empty folder in any convenient location on your hard disk (I created and use the folder <code>my_ruby_programs</code> on c: of my hard disk).</p>

<h4>Let us start using Git</h4>
<p>Since I work on a Windows box, I shall talk about how to use Git there. However, all the following commands are also available on all other platforms.</p>

<p>In Windows Explorer, right mouse click on your local folder <code>my_ruby_programs</code> and choose "Git Bash Here". This opens up a command window (bash shell).</p>

<h4>Introduce yourself to Git</h4>

<p>For all operating users, you now need to identify yourself to Git (you need to do this only once). With the bash shell still open type in the following:</p>
<pre>$ git config --global user.name "Your name here"
$ git config --global user.email "Your email id here"
</pre>

<p>Substitute in your own user name and email (note that Git does not allow accented characters in user name). This will set the info stored when you commit to a Git repository. Git has now been set up.</p>

<h4>Create your SSH Key</h4>

<p>The first step in using Git is to create your SSH Key. This will be used to secure communications between your machine and other machines, and to identify your source code changes. (If you already have an SSH key for other reasons, you can use it here, there is nothing Git-specific about this.)</p>

<p>To create our ssh key, type the command:</p>
<pre>$ ssh-keygen -C "username@email.com" -t rsa
</pre>
<p>(with your own email address, of course).</p>

<p>Accept the default key file location. When prompted for a passphrase, make one up and enter it. If you feel confident that your own machine is secure, you can use a blank passphrase, for more convenience and less security. Note where it told you it stored the file. On the machine I tested with, it was stored in "c:\Documents and Settings\A\.ssh\". <em>Memorize your passphrase carefully. If you forget it, you will NOT be able to recover it</em>.</p>

<p>Open the public file <code>id_rsa.pub</code> with a text editor. The text in there is your "public SSH key".</p>

<h2>Using GitHub</h2>

<h3>What's GitHub?</h3>

<p>GitHub is a social code site optimized for hosting and sharing Git repositories. Putting a copy of your Git repository at GitHub serves two purposes:</p>

<ol>
<li>it's a full backup of your code (including the full history of commits).</li>
<li>it makes any future collaboration much easier. This step is optional, but being a GitHub member will open the door to participating in a wide variety of open-source projects.</li>
</ol>

<h4>Set up your GitHub account</h4>

<p>Go to <a href="https://github.com/signup/free">https://github.com/signup/free</a> and sign up for a free account. Remember, this account can have unlimited public repositories and public collaborators (the total number of users who may read, write and fork your public repositories). Also, make sure that Javascript is enabled in your browser.</p>

<p>After you have created a GitHub account, login and please click on "Edit Your Profile" and fill in the relevant details in your GitHub account.</p>

<h4>Creating a new repository</h4>

<p>If you are already logged into your GitHub account you just created above, click on the "dashboard" link at the top right-hand-side of your GitHub page, you will see a "New Repository" button. Click on "New Repository" to create a new public repository (fill in the details like Project name, description etc.) Use the name <code>my_ruby_programs</code> for your Project name.</p>

<p><b>Important:</b> GitHub will show you a page with some instructions like Global setup, Next steps etc. - please keep this page open and get back to your already open Bash shell for the folder <code>my_ruby_programs</code>. Currently your folder <code>my_ruby_programs</code> is empty.</p>

<p>Next we shall put our local folder <code>my_ruby_programs</code> under Git management. In the open Bash shell type:</p>
<pre>$ git init
$ touch README
$ git add README
$ git commit -m 'first commit'
</pre>

<p>The <code>git init</code> command creates an empty Git repository or reinitializes an existing one. It has created a repository in the current folder i.e. <code>my_ruby_programs</code>. Git has created a <code>.git</code> subdirectory in your folder <code>my_ruby_programs</code> that will hold your changes locally (in compressed form). The new local repo will not contain anything yet.</p>

<p>The <code>touch README</code> command creates the file <code>README</code>, if the file does not already exist. If the file already exists, the accessed / modification time is updated for that file.</p>

<p>In Git, you "stage" things before you commit them. You do this with the <code>git add</code> command (for example: <code>git add README</code>). This adds specific content to the "stage". To stage all changes and new files, we type <code>git add .</code></p>

<p>The <code>git add .</code> command will take the working directory and all subdirectories and every single file, i.e. it adds all content to the "stage" (this snapshot is now stored in a temporary staging area which Git calls the "index"). If you make any changes to a file after staging (but before committing), you'll need to <code>git add</code> the file again.</p>

<p>When you get your changes just the way you want them added to the current revision, then you need to commit that revision to your local repository (this permanently stores the contents of the index in the repository).</p>

<p>We already have something staged and ready and it is time to commit it. We do it as follows <code>git commit -m 'first commit'</code>.</p>

<h4>Add your SSH key to GitHub</h4>

<p>Access your account on GitHub and Click "Account Settings" > Click "SSH Public Keys" > Click "Add another public key"</p>
<p>Open the <code>id_rsa.pub</code> file (which we had talked about earlier) with a text editor (Notepad, TextEdit, or gedit will do just fine). This is your public SSH key. You may need to turn on "view hidden files" to find it because the .ssh directory is hidden. It's important you copy your SSH key exactly as it is written without adding any newlines or whitespace. Now paste it into the "Key" field. Hit "Add Key".</p>

<p>In your open Bash shell, type:</p>
<pre>$ git remote add origin git@github.com:SatishTalim/myrubyprograms.git
</pre>
<p>Replace SatishTalim (use your username) with what's shown on the already open GitHub page. The above command needs to be executed only once in case you are not going to change the remote repository.</p>

<p>Now type:</p>
<pre>$ git push -u origin master
</pre>

<p>Once your changes are committed to your local repository, you need to push them to the remote repository for others to get at. To do that, you need to execute <code>git push</code>, which will push all the changes from your local repository up to the remote repository. We want to push changes back to the original repository, which is aliased as <em>origin</em>, to the master branch.</p>
<p>Here's my sample GitHub repository - <a href="https://github.com/SatishTalim/myrubyprograms">https://github.com/SatishTalim/myrubyprograms</a>.</p>

<p><b>Note:</b> From this point onwards, whenever you create a new program, or modify an existing program in the folder <code>my_ruby_programs</code>, open a Bash shell in that folder and type:</p>
<pre>$ git add .
$ git commit -m "commit"
$ git push origin master
</pre>

<p>The GitHub repository will show you the latest files that you have uploaded.</p>

<h3>Using Git &amp; GitHub eBook (Updated 15th Sept. 2011)</h3>
<p><a href="http://rubylearning.com/blog/using-git-github-ebook/">Using Git &amp; GitHub eBook</a> is an easy-to-follow guide to learn the essential features of both Git and GitHub that you'll end up using every day.</p>
<p>It is priced at a reasonable US$ 7. The money collected helps me maintain the site and provide quality content to you all.</p>
<p>Purchase of this eBook is <b>not mandatory</b>.</p>

<h2>Creating a simple webpage using HTML5, CSS and JavaScript</h2>
<p>As a web developer if you plan to build web applications using Rails or Sinatra or some Ruby based framework, you cannot do well if you do not know the basics of HTML, CSS and Javascript. Here, we shall be just skimming the surfcae. It is in your interest to read in depth and learn these technologies.</p>

<h3>A Webpage, Step by Step</h3>
<ol>
<li><b>Start with content.</b> As a starting point, we will add raw text content and see what browsers do with it.</li>
<li><b>Give the document structure.</b> You will learn some HTML elements and the elements that give a document its structure.</li>
<li><b>Identify text elements.</b> You will describe the content using the appropriate text elements and learn about the proper way to use HTML.</li>
<li><b>Add an image.</b> By adding an image to the page, you'll learn about attributes and empty elements.</li>
<li><b>Change the look with a style sheet.</b> This exercise gives you a taste of formatting content with Cascading Style Sheets (CSS).</li>
</ol>

<h3>Before we begin, Launch a Text Editor</h3>
<p>The text editor that is provided by your operating system, such as Notepad (Windows) or TextEdit (Mac), will do for these purposes.</p>

<p>On your hard disk, create a local folder that will contain all of the files for the site. Your folder should be organized like this:</p>
<pre>- DosaSite
  |- config.ru
  |- public
    |- index.html
    |- stylesheets
    |- images
</pre>

<h4>Step 1: Start with content</h4>
<p>In your text editor, type the following. Just copy it as you see here. Keep the line breaks.</p>

<pre>Dosa Diner

The Restaurant
The Dosa Diner offers casual lunch and dinner fare in a hip atmosphere. The menu changes regularly to highlight the freshest ingredients.

Catering Services
You have fun... we'll do the cooking. Dosa Diner Catering can handle events from snacks for bridge club to elegant corporate fundraisers.

Location and Hours
Deccan Corner in Pune, India;
Monday through Thursday 11am to 9pm, Friday and Saturday, 11am to midnight
</pre>

<p>Select "Save" or "Save as" from the File menu to get the Save As dialog box. Save this text file as <code>index.html</code> in the <code>DosaSite/public</code> folder. The filename needs to end in <code>.html</code> to be recognized by the browser as a web document.</p>

<p>Launch your favorite browser (I use Chrome) and choose "Open" or "Open File" from the File menu. Navigate to <code>index.html</code> and select the document to open it in the browser.</p>

<p>Our content is not looking good. Your browser ignores the line breaks in the source document.</p>

<h4>Step 2: Give the document structure</h4>
<p>HTML is a language for describing web pages.</p>
<ul>
<li>HTML stands for <b>H</b>yper <b>T</b>ext <b>M</b>arkup <b>L</b>anguage.</li>
<li>HTML is not a programming language, it is a <b>markup language</b>.</li>
<li>A markup language is a set of <b>markup tags</b>.</li>
<li>HTML uses <b>markup tags</b> to describe web pages</li>
</ul>

<p>HTML markup tags are usually called HTML tags.</p>
<ul>
<li>HTML tags are keywords surrounded by <b>angle brackets</b> like &lt;html&gt;</li>
<li>HTML tags normally <b>come in pairs</b> like &lt;b&gt; and &lt;/b&gt;</li>
<li>The first tag in a pair is the <b>start tag</b>, the second tag is the <b>end tag</b></li>
<li>Start and end tags are also called <b>opening tags</b> and <b>closing tags</b></li>
</ul>

<p>Here's a sample webpage that uses these HTML tags:</p>
<pre>&lt;!doctype html&gt;
&lt;html&gt;
  &lt;body&gt;

    &lt;h1&gt;My First Heading&lt;/h1&gt;

    &lt;p&gt;My first paragraph.&lt;/p&gt;

  &lt;/body&gt;
&lt;/html&gt;
</pre>

<p>In today's context, it's preferable that we use HTML5.</p>

<p><b>Note:</b></p>
<ol>
<li>The <code>doctype</code> definition belongs at the top of your HTML file and tells the browser the type of your document. By using a <code>doctype</code> the browser is able to be more precise in the way it interprets and renders your pages. Using a <code>doctype</code> is highly recommended. The <code>doctype</code> for HTML5 is simply <code>&lt;!doctype html&gt;</code></li>
<li>The text between &lt;html&gt; and &lt;/html&gt; describes the web page</li>
<li>The text between &lt;body&gt; and &lt;/body&gt; is the visible page content</li>
<li>The text between &lt;h1&gt; and &lt;/h1&gt; is displayed as a heading</li>
<li>The text between &lt;p&gt; and &lt;/p&gt; is displayed as a paragraph</li>
</ol>

<p>Open the newly created <code>index.html</code> document, if it isn't open already. Edit and save the <code>index.html</code> document, such that it looks like this:</p>

<pre>&lt;!DOCTYPE html&gt;
&lt;html&gt;

  &lt;head&gt;
    &lt;title&gt;Dosa Diner&lt;/title&gt;
    &lt;meta charset="utf-8"&gt;
  &lt;/head&gt;

  &lt;body&gt;
  Dosa Diner

  The Restaurant
  The Dosa Diner offers casual lunch and dinner fare in a hip atmosphere. The menu changes regularly to highlight the freshest ingredients.

  Catering Services
  You have fun... we'll do the cooking. Dosa Diner Catering can handle events from snacks for bridge club to elegant corporate fundraisers.

  Location and Hours
  Deccan Corner in Pune, India;
  Monday through Thursday 11am to 9pm, Friday and Saturday, 11am to midnight
  &lt;/body&gt;

&lt;/html&gt;
</pre>

<p>Open the <code>index.html</code> document in the browser or hit "refresh" or "reload" if it is already open. Our content is still not looking good.</p>

<p>Note that we have used <code>&lt;meta charset="utf-8"&gt;</code>. When you specify the <code>meta</code> tag in HTML5, just supply the tag along with a character encoding.</p>

<h4>Step 3: Identify text elements</h4>
<p>Let us add the markup that identifies headings, subheads and paragraphs. Open the newly created <code>index.html</code> document, if it isn't open already. Edit and save the <code>index.html</code> document, such that it looks like this:</p>
<pre>&lt;!DOCTYPE html&gt;
&lt;html&gt;

  &lt;head&gt;
    &lt;title&gt;Dosa Diner&lt;/title&gt;
    &lt;meta charset="utf-8"&gt;

  &lt;/head&gt;

  &lt;body&gt;
  &lt;h1&gt;Dosa Diner&lt;/h1&gt;

  &lt;h2&gt;The Restaurant&lt;/h2&gt;
  &lt;p&gt;The Dosa Diner offers casual lunch and dinner fare in a hip atmosphere. The menu changes regularly to highlight the freshest ingredients.&lt;/p&gt;

  &lt;h2&gt;Catering Services&lt;/h2&gt;
  &lt;p&gt;You have fun... we'll do the cooking. Dosa Diner Catering can handle events from snacks for bridge club to elegant corporate fundraisers.&lt;/p&gt;

  &lt;h2&gt;Location and Hours&lt;/h2&gt;
  &lt;p&gt;Deccan Corner in Pune, India;
  Monday through Thursday 11am to 9pm, Friday and Saturday, 11am to midnight&lt;/p&gt;
  &lt;/body&gt;

&lt;/html&gt;
</pre>

<p>Open the <code>index.html</code> document in the browser or hit "refresh" or "reload" if it is already open. Now our webpage looks much better.</p>

<h4>Step 4: Add an image</h4>
<p>Create the folder as follows:</p>
<pre>DosaSite
  |- public
    |- index.html
    |- images
</pre>
<p>Download the <a href="http://rubylearning.com/images/dosa.jpg">image</a> and store the same in the folder <code>DosaSite/public/images</code></p>

<p>In HTML, images are defined with the <code>&lt;img&gt;</code> tag.</p>

<p>The <code>&lt;img&gt;</code> tag does not have text content and is said to be empty, which means that it contains attributes only. Empty elements are terminated by adding a trailing slash preceded by a space before the closing bracket.</p>

<p>To display an image on a page, you need to use the <code>src</code> attribute. <code>src</code> stands for "source". The value of the <code>src</code> attribute is the <a href="http://rubylearning.com/images/dosa.jpg">URL</a> of the image you want to display. The required <code>alt</code> attribute specifies an alternate text for an image, if the image cannot be displayed.</p>

<p>Open the newly created <code>index.html</code> document, if it isn't open already. Edit and save the <code>index.html</code> document, such that it looks like this:</p>
<pre>&lt;!DOCTYPE html&gt;
&lt;html&gt;

  &lt;head&gt;
    &lt;title&gt;Dosa Diner&lt;/title&gt;
    &lt;meta charset="utf-8"&gt;
  &lt;/head&gt;

  &lt;body&gt;
  &lt;h1&gt;&lt;img src="images/dosa.jpg" alt="Dosa Diner" /&gt;Dosa Diner&lt;/h1&gt;

  &lt;h2&gt;The Restaurant&lt;/h2&gt;
  &lt;p&gt;The Dosa Diner offers casual lunch and dinner fare in a hip atmosphere. The menu changes regularly to highlight the freshest ingredients.&lt;/p&gt;

  &lt;h2&gt;Catering Services&lt;/h2&gt;
  &lt;p&gt;You have fun... we'll do the cooking. Dosa Diner Catering can handle events from snacks for bridge club to elegant corporate fundraisers.&lt;/p&gt;

  &lt;h2&gt;Location and Hours&lt;/h2&gt;
  &lt;p&gt;Deccan Corner in Pune, India;
  Monday through Thursday 11am to 9pm, Friday and Saturday, 11am to midnight&lt;/p&gt;
  &lt;/body&gt;

&lt;/html&gt;
</pre>
<p>Open the <code>index.html</code> document in the browser or hit "refresh" or "reload" if it is already open. The image should show up in the browser.</p>

<h4>Step 5: Change the look with a style sheet</h4>
<p>Create the folder as follows:</p>
<pre>- DosaSite
  |- public
    |- index.html
    |- stylesheets
</pre>
<p>An external style sheet is a plain-text document with at least one style sheet rule. The style sheet should be named with the <code>.css</code> suffix, so call it <code>dosasite.css</code>. Here are the contents of our style sheet:</p>
<pre>body {
  background color: #C2A7F2;
  font-family: sans-serif;
}
h1 {
  color: #2A1959;
  border-bottom: 2px solid #2A1959;
}
h2 {
  color: #474B94;
  font-size: 1.2em;
}
h2, p {
  margin-left: 120px;
}
</pre>
<p>Let's quickly look at what we have defined in the style sheet. The background-color property specifies the background color of an element (in our case the <code>body</code>). With CSS, a color is most often specified by a HEX value - like "#ff0000".</p>

<p>In CSS, there are two types of font family names:</p>
<ul>
<li><b>generic family</b> - a group of font families with a similar look (like "Serif" or "Monospace")</li>
<li><b>font family</b> - a specific font family (like "Times New Roman" or "Arial")</li>
</ul>
<p>On computer screens, sans-serif fonts are considered easier to read than serif fonts.</p>

<p>CSS colors are defined using a hexadecimal (hex) notation for the combination of Red, Green, and Blue color values (RGB). The lowest value that can be given to one of the light sources is 0 (hex 00). The highest value is 255 (hex FF). Hex values are written as 3 double digit numbers, starting with a # sign.</p>

<p>The border-bottom shorthand property sets all the bottom border properties in one declaration. The properties that can be set, are (in order): border-bottom-width, border-bottom-style, and border-bottom-color. It does not matter if one of the values above are missing, e.g. border-bottom:solid #ff0000; is allowed.</p>

<p>The font-size property sets the size of a font.</p>
<p>The margin-left property sets the left margin of an element.</p>

<p>The best method to refer to an external style sheet from within the HTML document is to create a <code>link</code> to the <code>dosasite.css</code> document, using the <code>link</code> element in the <code>head</code> of the document, as shown:</p>
<pre>&lt;!DOCTYPE html&gt;
&lt;html&gt;

  &lt;head&gt;
    &lt;title&gt;Dosa Diner&lt;/title&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;link rel="stylesheet" href="stylesheets/dosasite.css"&gt;
  &lt;/head&gt;

  &lt;body&gt;
  &lt;h1&gt;&lt;img src="images/dosa.jpg" alt="Dosa Diner" /&gt;Dosa Diner&lt;/h1&gt;

  &lt;h2&gt;The Restaurant&lt;/h2&gt;
  &lt;p&gt;The Dosa Diner offers casual lunch and dinner fare in a hip atmosphere. The menu changes regularly to highlight the freshest ingredients.&lt;/p&gt;

  &lt;h2&gt;Catering Services&lt;/h2&gt;
  &lt;p&gt;You have fun... we'll do the cooking. Dosa Diner Catering can handle events from snacks for bridge club to elegant corporate fundraisers.&lt;/p&gt;

  &lt;h2&gt;Location and Hours&lt;/h2&gt;
  &lt;p&gt;Deccan Corner in Pune, India;
  Monday through Thursday 11am to 9pm, Friday and Saturday, 11am to midnight&lt;/p&gt;
  &lt;/body&gt;

&lt;/html&gt;
</pre>

<p>Note that CSS has been declared the standard, and default, style for HTML5.</p>

<h4>Add some JavaScript</h4>
<p>In HTML5, JavaScript is now the standard and default scripting language.</p>

<p>Remember that as the browser loads your page, it also creates an internal model of your webpage (document) that contains all the elements of your HTML markup. For each element in your HTML, the browser creates an object that represents it and places it in a tree-like structure with all the other elements. We call this tree the <b>Document Object Model</b> or the <b>DOM</b> for short. While the browser is loading your page it's also loading your JavaScript code, which typically <em>begins executing just after the page loads</em>. JavaScript interacts with your page through the DOM. Your JavaScript can interact with the DOM to get access to the elements and the content in them. JavaScript can also use the DOM to create or remove elements. When JavaScript modifies the DOM, the browser updates the page dynamically, so you see new content on your page.</p>
<p>The HTML5 Application Programming Interfaces (APIs) give you access to audio, video, 2D drawing with the canvas, local storage and a bunch of other great technologies needed to build apps. And remember, to make use of all these APIs, we need JavaScript.</p>

<p>JavaScript is a full-fledged programming language and you can do pretty much anything with it you can with other languages, and even more because we're programming inside a web page!</p>

<h5>How and where to add JavaScript to your pages</h5>
<ul>
<li>Place your script inline, in the &lt;head&gt; element - the most common way to add code to your pages is to put a &lt;script&gt; element in the head of your page. When you add JavaScript in the &lt;head&gt; element, it is executed as soon as the browser parses the head (which it does first!), before it has parsed the rest of the page. Example: <code>&lt;script&gt; ... &lt;/script&gt;</code></li>
<li>Add your script by referencing a separate JavaScript file - you can also link to a separate file containing JavaScript code. Put the URL of the file in the <code>src</code> attribute of the opening &lt;script&gt; tag and make sure you close the script element with &lt;/script&gt;. If you're linking to a file in the same directory, you can just use the name of the file.</li>
<li>Add your code in the body of the document, either inline or as a link to a separate file - or, you can put your code right in the body of your HTML. Again, enclose your JavaScript code in the &lt;script&gt; element (or reference a separate file in the <code>src</code> attribute). JavaScript in the body of your page is executed when the browser parses the body (which it does, typically, top down).</li>
</ul>

<p>When the user loads our Dosa Diner webpage, we will give a message to the user using JavaScript's <code>alert</code> as follows:</p>
<pre>&lt;!DOCTYPE html&gt;
&lt;html&gt;

  &lt;head&gt;
    &lt;title&gt;Dosa Diner&lt;/title&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;link rel="stylesheet" href="stylesheets/dosasite.css"&gt;
    &lt;script&gt;
      alert("Hello Course Participants");
    &lt;/script&gt;
  &lt;/head&gt;

  &lt;body&gt;
  &lt;h1&gt;&lt;img src="images/dosa.jpg" alt="Dosa Diner" /&gt;Dosa Diner&lt;/h1&gt;

  &lt;h2&gt;The Restaurant&lt;/h2&gt;
  &lt;p&gt;The Dosa Diner offers casual lunch and dinner fare in a hip atmosphere. The menu changes regularly to highlight the freshest ingredients.&lt;/p&gt;

  &lt;h2&gt;Catering Services&lt;/h2&gt;
  &lt;p&gt;You have fun... we'll do the cooking. Dosa Diner Catering can handle events from snacks for bridge club to elegant corporate fundraisers.&lt;/p&gt;

  &lt;h2&gt;Location and Hours&lt;/h2&gt;
  &lt;p&gt;Deccan Corner in Pune, India;
  Monday through Thursday 11am to 9pm, Friday and Saturday, 11am to midnight&lt;/p&gt;
  &lt;/body&gt;

&lt;/html&gt;
</pre>

<p>We have finished the Dosa Diner webpage.</p>

<h3>Store your webpage files on GitHub</h3>
<p>Let us now store our static webpage and related files on Github.</p>

<p>Log into your GitHub a/c and create a new repository. Call it <code>DosaSite</code>. Keep the GitHub page open and on your local hard-disk, put your local folder <code>DosaSite</code> under Git management. Open a Bash shell in the folder <code>DosaSite</code> and type:</p>

<pre>$ git init
$ touch README
$ git add .
$ git commit -m 'first commit'
$ git remote add origin git@github.com:SatishTalim/DosaSite.git
$ git push -u origin master
</pre>
<p>Replace SatishTalim (use your username) with what's shown on the already open GitHub page.</p>
<p>In the open GitHub page, click on Continue and you should see your new repo <code>DosaSite</code> there. Mine is <a href="https://github.com/SatishTalim/DosaSite">https://github.com/SatishTalim/DosaSite</a></p>

<h2>Understanding HTTP concepts</h2>

<p>When you start building web applications, you would be dealing with HTTP a lot.</p>

<h3>What's HTTP?</h3>

<p>HTTP means HyperText Transfer Protocol. A protocol is just a convention for computer dialogs. It assumes that the computers participating in the conversation have a way of sending messages to each other.</p>

<p>HTTP uses a simple conversation pattern: the client connects to the server, initiates the dialog by asking the server for something, the server then tries to provide the client with an answer (back).</p>

<p>An example of a simple HTTP request and response would be the client asking "give me the file A" and the server answering "I have it, here is the content of file A: (...content of file A...)".</p>

<p>But in reality the protocol uses its own simplified language which looks more like "GET /fileA" answered by "200 OK (...content of file A...)".</p>
</div>

<div style="width:image 560 px; font-size:80%; text-align:center;"><img src="http://rubylearning.com/images/HTTP1.jpg" alt="HTTP" width="560" style="padding-bottom:0.5em;" /><br />HTTP</div>

<div>

<p>The basic principle of HTTP, and the Web in general, is that every resource (such as a web page) available on the Web has a distinct Uniform Resource Locator (URL), and that web clients can use HTTP verbs such as <code>GET</code>, <code>POST</code>, <code>PUT</code>, and <code>DELETE</code> to retrieve or otherwise manipulate those resources.</p>

<h4>Loading a web page</h4>

<p>When a browser loads a web page, it does a <code>GET</code> request for the URL requested. The content of the page is usually in a special text format called HTML that allows links, images and various style effects.</p>

<p>The browser analyses the HTML in order to display it to the user. But doing so, it may find that it needs more content to render the page correctly, like images.</p>

<p>When that happens, the browser initiates one HTTP request for each image.</p>

<p>When all the necessary information is downloaded, it is combined into the page the user sees on his screen.</p>
</div>

<div style="width:image 560 px; font-size:80%; text-align:center;"><img src="http://rubylearning.com/images/HTTP2.jpg" alt="HTTP" width="560" style="padding-bottom:0.5em;" /><br />HTTP</div>

<div>
<h3>HTTP request methods (verbs)</h3>

<h4>GET</h4>

<p>A resource is some chunk of information that can be identified by a URL (it's the R in URL - Uniform Resource Locator). The most common kind of resource is a file, but a resource may also be a dynamically-generated query result, a document that is available in several languages, or something else.</p>

<p><code>GET</code> is the most common HTTP method; it says "give me this resource". Method names are always uppercase.</p>

<p>A typical request looks like this:</p>
<pre>GET /path/to/file/index.html HTTP/1.1
</pre>

<p>The path is the part of the URL after the host name, also called the request URI (a URI is like a URL, but more general).</p>

<p>The HTTP version always takes the form "HTTP/x.x", uppercase.</p>

<h4>POST</h4>

<p>A <code>POST</code> request is used to send data to the server to be processed in some way. A <code>POST</code> request is different from a <code>GET</code> request in the following ways:</p>
<ul>
<li>There's a block of data sent with the request, in the message body.</li>
<li>The request URI is not a resource to retrieve; it's usually a program to handle the data you're sending.</li>
<li>The HTTP response is normally program output, not a static file.</li>
</ul>

<h4>PUT</h4>

<p>A <code>PUT</code> request uploads a document from either the local file system or a remote HTTP server to the destination HTTP server.</p>

<h4>DELETE</h4>

<p>A <code>DELETE</code> request deletes a resource (or makes it unavailable) for future references.</p>

<h3>HTTP response codes</h3>
<p>After a client (such as a web browser) sends a request corresponding to one of the HTTP verbs, the web server responds with a numerical code indicating the HTTP status of the response. For example, a status code of 200 means "success", and a status code of 301 means "permanent redirect". If you install <b>curl</b> (when you installed the Bash shell, curl was also installed), a command-line client that can issue HTTP requests, you can see this directly at, e.g., www.satishtalim.com (where the --head flag prevents curl from returning the whole page). Open a Bash shell and type:</p>

<pre>$ curl --head www.satishtalim.com
  HTTP/1.1 200 OK
  .
  .
  .
</pre>

<p>Here satishtalim.com indicates that the request was successful by returning the status 200 OK. In contrast, google.com is permanently redirected (to www.google.com, naturally), indicated by status code 301 (a "301 redirect"):</p>
<pre>$ curl --head rubylearning.org
  HTTP/1.1 301 Moved Permanently
  Location: http://www.google.com/
  .
  .
  .
</pre>

<p>The Internet has become an inescapable part of software development, and Ruby has a significant number of libraries available to deal with the plethora of Internet services available.</p>

<h3>net/http library</h3>
<p>The <a href="http://www.ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/index.html">net/http</a> library comes standard with Ruby and provides a simple client to fetch headers and web page contents using the HTTP and HTTPS protocols. The <code>Net::HTTP</code> is designed to work closely with <code>URI</code>. <code>URI::HTTP#host</code>, <code>URI::HTTP#port</code> and <code>URI::HTTP#request_uri</code> are designed to work with <code>Net::HTTP</code>. The <code>URI</code> class is automatically loaded by <code>net/http</code>.</p>

<h4>Using URI</h4>
<p>Let's write a program <code>neturi1.rb</code> and store it in the folder <code>my_ruby_programs</code>:</p>
<pre># neturi1.rb
require 'net/http'

uri = URI('http://rubylearning.com/data/text.txt')
res = Net::HTTP.get_response(uri)
puts res.code    # => '200'
puts res.message # => 'OK'

puts Net::HTTP.get(uri) # => String
</pre>

<p>This example loads the <code>net/http</code> library and connects to the URL http://rubylearning.com/data/text.txt</p>

<p>The <code>Net::HTTP.get_response(uri)</code> sends a <code>GET</code> request to the target and returns the HTTP response as a <code>Net::HTTPResponse</code> object. The target is specified as (uri). We can use the <code>code</code> and <code>message</code> methods to return the response data.</p>

<p>The <code>Net::HTTP.get(uri)</code> performs an HTTP <code>GET</code> request for <code>text.txt</code>. This file's contents are then returned and displayed. If you load the URL http://rubylearning.com/data/text.txt in your web browser, you'll get the same response as Ruby.</p>


<p>The <a href="http://www.ruby-doc.org/stdlib-1.9.3/libdoc/net/http/rdoc/Net/HTTP.html#method-i-start">Net::HTTP.start</a> method opens a TCP connection and HTTP session. When this method is called with a block, it passes the <code>Net::HTTP</code> object to the block, and closes the TCP connection and HTTP session after the block has been executed.</p>

<p>Let's write a program that uses the <code>start</code>. Let's call it <code>nethttp1.rb</code> and store it in the folder <code>my_ruby_programs</code>:</p>
<pre># nethttp1.rb
require 'net/http'

url = URI.parse('http://rubylearning.com/data/text.txt')

Net::HTTP.start(url.host, url.port) do |http|
  req = Net::HTTP::Get.new(url.path)
  puts http.request(req).body
end
</pre>

<p>The <code>URI</code> class is used to parse the supplied URL. An object is returned whose methods <code>host</code>, <code>port</code>, and <code>path</code> supply different parts of the URL for <code>Net::HTTP</code> to use. Note that in this example you provide two parameters to the main <code>Net::HTTP.start</code> method: the URL's hostname and the URL's port number. The port number is optional, but <code>URI.parse</code> is clever enough to return the default HTTP port number of 80.</p>

<h3>Using open-uri</h3>
<p><code>open-uri</code> is a standard Ruby library that wraps up the functionality of <code>net/http</code>, <code>net/https</code>, and <code>net/ftp</code> into a single package. With <code>open-uri</code> retrieving a document from the Web becomes much like opening a text file on the local machine.</p>

<pre># netouri.rb
require 'open-uri'

f = open('http://rubylearning.com/data/text.txt')
puts f.readlines.join
</pre>
<p>As with <code>File::open</code>, <code>open</code> returns an I/O object (technically a <code>StringIO</code> object), and you can use a method such as <code>readlines</code>.</p>

<h3>Using Hpricot</h3>
<p>The <b>Hpricot</b> library is not part of Ruby but is very popular. Hpricot is a very rich Ruby library designed to make HTML parsing fast, easy, and fun. We'll only scratch the surface here.</p>
<p>To install Hpricot, open a new command window and type:</p>
<pre>gem install hpricot
</pre>

<p>Hpricot can work directly with <code>open-uri</code> to load HTML from remote files.</p>

<pre># nethpcot.rb
require 'open-uri'
require 'hpricot'

page = Hpricot(open('http://rubylearning.com'))
puts "Page title is: " + page.at(:title).inner_html
</pre>

<h2>Creating one's own Ruby Gem</h2>

<h3>What's a Ruby Gem?</h3>
<p>To solve various problems with Ruby, you might develop your own libraries. Also, you might want to open-source your libraries to get help from the Ruby community and have many developers working on the same.</p>

<p>A gem is a packaged Ruby application or library. RubyGems is the standard way to distribute Ruby applications and libraries and is available to you after you have downloaded and installed Ruby 1.9+.</p>

<h3>Let us create a simple Ruby library</h3>
<p>Let's first create a simple library that extends the <code>String</code> class and store this in a file called <code>my_string_extend.rb</code> in the folder <code>my_string_extend/lib</code>. The <em>lib</em> folder will contain the Ruby code related to the library:</p>
<pre># my_string_extend.rb
class String
  def writesize
    self.size
  end
end
</pre>
<p>The library opens up the <code>String</code> class and adds a method <code>writesize</code> (which returns the size of the string).</p>

<p>For open-source applications, the gem server to use for your applications is the one provided at <a href="https://rubygems.org/">https://rubygems.org/</a>. This is where users will look, and is where gem will also look by default when you issue a <code>gem install</code> command. Please make sure that the name of your gem isn't in use already. Type:</p>
<pre>$ gem list -r my_string_extend

*** REMOTE GEMS ***
</pre>

<p>Observe that no gem of the name <code>my_string_extend</code> exists. We are safe! Now let us now turn our library into a gem, so that one can use it anywhere.</p>

<h3>Steps for publishing our gem</h3>

<p><b>1.</b> Update to the latest RubyGem - In the folder <code>my_string_extend</code> open a command window and type:</p>
<pre>$ gem update --system
</pre>

<p><b>2.</b> Create an account on RubyGems.org - <a href="http://rubygems.org/sign_up">http://rubygems.org/sign_up</a> and confirm your email. Later on, you'll need to provide your login credentials the first time you push a gem to the server.</p>

<p><b>3.</b> Create a Gem Specification - In the folder <code>my_string_extend</code> copy the following file <code>my_string_extend.gemspec</code> and edit it as per your needs:</p>
<pre>Gem::Specification.new do |s|
  s.name        = 'my_string_extend'
  s.version     = '0.0.1'
  s.date        = '2011-10-27'
  s.summary     = "String Extend"
  s.description = "The library opens up the String class and adds a method writesize, which returns the size of the string."
  s.authors     = ["Satish Talim"]
  s.email       = ["satish@rubylearning.org"]
  s.homepage    = "http://rubylearning.org/"
  s.files       = ["lib/my_string_extend.rb"]
end
</pre>

<p>The gemspec defines what's in the gem, who made it, and the version of the gem. The gemspec is a chunk of Ruby code that the gem command will read and execute to understand our app, such as its name, files, and dependencies. It's also our interface to RubyGems.org, all the information you see on a gem page comes from the gemspec.</p>

<p><b>4.</b> Once we have our gemspec, we have to build a gem from it. In the folder <code>my_string_extend</code> type:</p>
<pre>$ gem build my_string_extend.gemspec
  Successfully built RubyGem
  Name: my_string_extend
  Version: 0.0.1
  File: my_string_extend-0.0.1.gem
</pre>

<p>We can then install it locally to test it out:</p>
<pre>$ gem install ./my_string_extend-0.0.1.gem
Successfully installed my_string_extend-0.0.1
1 gem installed
Installing ri documentation for my_string_extend-0.0.1...
Installing RDoc documentation for my_string_extend-0.0.1...
</pre>

<p>Lets require our gem and use it:</p>
<pre>$ irb --simple-prompt
&gt;&gt; require 'my_string_extend'
=> true
&gt;&gt; puts "Hello".writesize
5
=> nil
&gt;&gt; quit
</pre>

<p><b>5.</b> Now publish our gem out to RubyGems.org. In the folder <code>my_string_extend</code> type:</p>
<pre>$ gem push my_string_extend-0.0.1.gem
Enter your RubyGems.org credentials.
Don't have an account yet? Create one at http://rubygems.org/sign_up
   Email:   satish@rubylearning.org
Password:

Pushing gem to https://rubygems.org...
Signed in.
Pushing gem to https://rubygems.org...
Successfully registered gem: my_string_extend (0.0.1)
</pre>

<p>In just a few moments (usually a minute), your gem will be available for installation by anyone:</p>
<pre>$ gem list -r my_string_extend

*** REMOTE GEMS ***

my_string_extend (0.0.1)
</pre>
<p>Here's our Ruby gem on the RubyGems.org site</p>

</div>

<div style="width:image 560 px; font-size:80%; text-align:center;"><a href="https://rubygems.org/gems/my_string_extend"><img src="http://rubylearning.com/images/rubygem.jpg" alt="Rack App" width="560" style="padding-bottom:0.5em;" /></a><br />Our Ruby Gem</div>

<div>

<h2>Learning Rack</h2>
<h3>What's Rack?</h3>
<p>In the words of the author of Rack - <b>Christian Neukirchen</b>: Rack aims to provide a minimal API for connecting web servers supporting Ruby (like WEBrick, Mongrel etc.) and Ruby web frameworks (like Rails, Sinatra etc.).</p>

<p>Web frameworks such as Sinatra are built on top of Rack or have a Rack interface for allowing web application servers to connect to them.</p>

<p>The premise of Rack is simple - it just allows you to easily deal with HTTP requests.</p>

<p>HTTP is a simple protocol: it basically describes the activity of a client sending a HTTP request to a server and the server returning a HTTP response. Both HTTP request and HTTP response in turn have very similar structures. A HTTP request is a triplet consisting of a method and resource pair, a set of headers and an optional body while a HTTP response is in triplet consisting of a response code, a set of headers and an optional body.</p>

<p>Rack maps closely to this. A Rack application is a Ruby object that has a <code>call</code> method, which has a single argument, the <em>environment</em>, (corresponding to a HTTP request) and returns an array of 3 elements, <em>status</em>, <em>headers</em> and <em>body</em> (corresponding to a HTTP response).</p>

<p>Rack includes <em>handlers</em> that connect Rack to all these web application servers (WEBrick, Mongrel etc.).</p>

<p>Rack includes <em>adapters</em> that connect Rack to various web frameworks (Sinatra, Rails etc.).</p>

<p>Between the server and the framework, Rack can be customized to your applications needs using <em>middleware</em>. The fundamental idea behind Rack middleware is - come between the calling client and the server, process the HTTP request before sending it to the server, and processing the HTTP response before returning it to the client.</p>
</div>

<div style="width:image 560 px; font-size:80%; text-align:center;"><img src="http://rubylearning.com/images/rack.jpeg" alt="Rack App" width="560" style="padding-bottom:0.5em;" /><br />A Rack App</div>

<div>
<h3>Rack Documentation</h3>
<p><a href="http://rack.rubyforge.org/doc/">http://rack.rubyforge.org/doc/</a></p>

<h3>Installing Rack</h3>

<p>Note that I have Ruby 1.9.2 installed on a Windows box and all the programs in this article have been tested using that.</p>
<p>Let's check if we already have rack with us. Open a command window and type:</p>
<pre>irb --simple-prompt
&gt;&gt; require 'rack'
=> true
&gt;&gt;
</pre>

<p>Yes, rack's already there on your machine. If rack's not there you will get an error like:
<pre>LoadError: no such file to load -- rack
</pre>

<p>You can install rack by opening a new command window and typing:</p>
<pre>gem install rack
</pre>

<h3>A quick visit to Ruby's proc object</h3>
<p>Remember the <a href="http://rubylearning.com/satishtalim/ruby_procs.html">proc object from Ruby</a>? <em>Blocks are not objects</em>, but they can be converted into objects of class <code>Proc</code>. This can be done by calling the <code>lambda</code> method of the class <code>Object</code>. A block created with <code>lambda</code> acts like a Ruby method. The class <code>Proc</code> has a method <code>call</code> that invokes the block.</p>

<p>In irb type:</p>
<pre>&gt;&gt; my_rack_proc = lambda {puts 'Rack Intro'}
=> #&lt;Proc:0x1fc9038@(irb):2(lambda)&gt;
&gt;&gt; # method call invokes the block
?&gt; my_rack_proc.call
Rack Intro
=> nil
&gt;&gt;
</pre>

<h3>A simple Rack app - my_rack_proc</h3>
<p>As mentioned earlier, our simple Rack application is a Ruby object (not a class) that responds to <code>call</code> and takes exactly one argument, the <em>environment</em>. The <em>environment</em> must be a true instance of <code>Hash</code>. The app should return an Array of exactly three values: the <em>status</em> code (it must be greater than or equal to 100), the <em>headers</em> (must be a hash), and the <em>body</em> (the body commonly is an Array of Strings, the application instance itself, or a File-like object. The <em>body</em> must respond to method <code>each</code> and must only yield <code>String</code> values.) Let us create our new <code>proc</code> object. Type:</p>
<pre>&gt;&gt; my_rack_proc = lambda { |env| [200, {}, ["Hello. The time is #{Time.now}"]] }
=> #&lt;Proc:0x1f4c358@(irb):5(lambda)&gt;
&gt;&gt;
</pre>
<p>Now we can call the proc object my_rack_proc with the <code>call</code> method. Type:</p>
<pre>&gt;&gt; my_rack_proc.call({})
=> [200, {}, ["Hello. The time is 2011-10-24 09:18:56 +0530"]]
&gt;&gt;
</pre>
<p><b>my_rack_proc</b> is our single line Rack application.</p>

<p>In the above example, we have used an empty hash for headers. Instead, let's have something in the header as follows:</p>
<pre>&gt;&gt; my_rack_proc = lambda { |env| [200, {"Content-Type" => "text/plain"}, ["Hello. The time is #{Time.now}"]] }
=> #&lt;Proc:0x1f4c358@(irb):5(lambda)&gt;
&gt;&gt;
</pre>
<p>Now we can call the proc object my_rack_proc with the <code>call</code> method. Type:</p>
<pre>&gt;&gt; my_rack_proc.call({})
=> [200, {"Content-Type" => "text/plain"}, ["Hello. The time is 2011-10-24 09:18:56 +0530"]]
&gt;&gt;
</pre>

<p>We can run our Rack application (<b>my_rack_proc</b>) with any of the Rack handlers.</p>
<p>To look at the Rack handlers available, in irb type:</p>

<pre>&gt;&gt; Rack::Handler.constants
=> [:CGI, :FastCGI, :Mongrel, :EventedMongrel, :SwiftipliedMongrel, :WEBrick, :LSWS, :SCGI, :Thin]
&gt;&gt;
</pre>

<p>To get a handler for say <b>WEBrick</b> (the default <b>WEBrick</b>, web application server, that comes along with Ruby), type:</p>
<pre>&gt;&gt; Rack::Handler::WEBrick
=> Rack::Handler::WEBrick
&gt;&gt;
</pre>
<p>All of these handlers have a common method called <code>run</code> to run all the Rack based applications.</p>

<pre>&gt;&gt; Rack::Handler::WEBrick.run my_rack_proc
[2011-10-24 10:00:45] INFO WEBrick 1.3.1
[2011-10-24 10:00:45] INFO ruby 1.9.2 (2011-07-09) [i386-mingw32]
[2011-10-24 10:00:45] INFO WEBrick::HTTPServer#start: pid=1788 port=80
</pre>
<p>Open a browser window and type the url: <a href="http://localhost/">http://localhost/</a></p>

<p>In your browser window, you should see a string, something like this:</p>
<pre>Hello. The time is 2011-10-24 10:02:20 +0530
</pre>

<p><b>Note</b>: If you already have something running at port 80, you can run this app at a different port, say 9876. Type:</p>
<pre>&gt;&gt; Rack::Handler::WEBrick.run my_rack_proc, :Port => 9876
[2011-10-24 11:32:21] INFO  WEBrick 1.3.1
[2011-10-24 11:32:21] INFO  ruby 1.9.2 (2011-07-09) [i386-mingw32]
[2011-10-24 11:32:21] INFO  WEBrick::HTTPServer#start: pid=480 port=9876
</pre>
<p>Open a browser window and type the url: <a href="http://localhost:9876/">http://localhost:9876/</a></p>

<p>In your browser window, you should see a string, something like this:</p>
<pre>Hello. The time is 2011-10-24 10:02:20 +0530
</pre>

<h3>Another Rack app - my_method</h3>
<p>A Rack app need not be a lambda; it could be a method. Type:</p>
<pre>&gt;&gt; def my_method env
&gt;&gt; [200, {}, ["method called"]]
&gt;&gt; end
=> nil
</pre>

<p>We declare a method my_method that takes an argument env. The method returns three values.</p>

<p>Next type:</p>
<pre>&gt;&gt; Rack::Handler::WEBrick.run method(:my_method)
[2011-10-24 14:32:05] INFO  WEBrick 1.3.1
[2011-10-24 14:32:05] INFO  ruby 1.9.2 (2011-07-09) [i386-mingw32]
[2011-10-24 14:32:05] INFO  WEBrick::HTTPServer#start: pid=1644 port=80
</pre>
<p>Open a browser window and type the url: <a href="http://localhost/">http://localhost/</a></p>
<p>In your browser window, you should see something like this:</p>
<pre>method called
</pre>
<p><code>Method</code> objects are created by <code>Object#method</code>. They are associated with a particular object (not just with a class). They may be used to invoke the method within the object. The <code>Method.call</code> method invokes the method with the specified arguments, returning the method's return value.</p>
<p>Press <b>Ctrl-C</b> in irb to stop the <b>WEBrick</b> server.</p>

<h3>Using rackup</h3>
<p>The rack gem comes with a bunch of useful stuff to make life easier for a rack application developer. rackup is one of them.</p>

<p>rackup is a useful tool for running Rack applications. rackup automatically figures out the environment it is run in, and runs your application as FastCGI, CGI, or standalone with Mongrel or WEBrick - all from the same configuration.</p>

<p>To use rackup, you'll need to supply it with a rackup config file. By convention, you should use .ru extension for a rackup config file. Supply it a run RackObject and you're ready to go:</p>
<pre>$ rackup config.ru
</pre>

<p>By default, rackup will start a server on port 9292.</p>

<p>To view rackup help, open a command window and type:</p>
<pre>$ rackup --help
</pre>
<p>Let us create a config.ru file that contains the following:</p>
<pre>run lambda { |env| [200, {"Content-Type" => "text/plain"}, ["Hello. The time is #{Time.now}"]] }
</pre>
<p>This file contains <code>run</code>, which can be called on anything that responds to a <code>.call</code>.</p>

<p>To run our rack app, in the same folder that contains config.ru, type:</p>
<pre>$ rackup config.ru
[2011-10-24 15:18:03] INFO WEBrick 1.3.1
[2011-10-24 15:18:03] INFO ruby 1.9.2 (2011-07-09) [i386-mingw32]
[2011-10-24 15:18:03] INFO WEBrick::HTTPServer#start: pid=3304 port=9292
</pre>

<p>Open a browser window and type the url: <a href="http://localhost:9292/">http://localhost:9292/</a></p>
<p>In your browser window, you should see something like this:</p>
<pre>Hello. The time is 2011-10-24 15:18:10 +0530
</pre>
<p>Press <b>Ctrl-C</b> to stop the <b>WEBrick</b> server.</p>

<p>Now let's move our application from the config.ru file to my_app.rb file as follows:</p>
<pre># my_app.rb
class MyApp
  def call env
    [200, {"Content-Type" => "text/html"}, ["Hello Rack Participants"]]
  end
end
</pre>
<p>Also, our config.ru will change to:</p>
<pre>require './my_app'
run MyApp.new
</pre>

<p>To run our rack app, in the same folder that contains config.ru, type:</p>
<pre>rackup config.ru
[2011-10-25 06:18:16] INFO  WEBrick 1.3.1
[2011-10-25 06:18:16] INFO  ruby 1.9.2 (2011-07-09) [i386-mingw32]
[2011-10-25 06:18:16] INFO  WEBrick::HTTPServer#start: pid=2224 port=9292
</pre>

<p>Open a browser window and type the url: <a href="http://localhost:9292/">http://localhost:9292/</a></p>

<p>In your browser window, you should see something like this:</p>
<pre>Hello Rack Participants
</pre>
<p>Press <b>Ctrl-C</b> to stop the <b>WEBrick</b> server.</p>


<h2>Deploying Pure Rack Apps to Heroku</h2>
<h3>What's Heroku?</h3>
<p>Heroku (pronounced her-OH-koo) is a cloud application platform - a new way of building and deploying web apps.</p>

<h4>Create an account on Heroku</h4>

<p>Please ensure that you are connected to the internet and then create an account on Heroku (obviously do this only once) if you don't have one - <a href="http://heroku.com/signup">http://heroku.com/signup</a>.</p>

<p>On your local machine, open a new command window to install the Heroku gem file. Type:</p>
<pre>gem install heroku
</pre>

<p>Next, create a new folder, say <code>rackheroku</code>. Assuming that you have Git installed, open a Bash shell in that folder. You now need to identify yourself to Git (you need to do this only once). With the bash shell still open type in the following:</p>
<pre>git config --global user.name "Your name here"
git config --global user.email "Your email id"
</pre>

<p>Git does not allow accented characters in user name. This will set the info stored when you commit to a Git repository. Git has now been set up.</p>

<p>The first step in using Git is to create your SSH Key. This will be used to secure communications between your machine and other machines, and to identify your source code changes. (If you already have an SSH key for other reasons, you can use it here, there is nothing Git-specific about this.)</p>

<p>To create our ssh key, open a new command window and type:</p>
<pre>$ ssh-keygen -C "username@email.com" -t rsa
</pre>
<p>(with your own email address, of course).</p>

<p>Accept the default key file location. When prompted for a passphrase, make one up and enter it. If you feel confident that your own machine is secure, you can use a blank passphrase, for more convenience and less security. Note where it told you it stored the file. On my Windows box, it was stored in "C:\Documents and Settings\A\.ssh\". Memorize your passphrase carefully. If you forget it, you will NOT be able to recover it.</p>
<p>Open the public file id_rsa.pub with a text editor. The text in there is your "public SSH key".</p>

<p>Upload your public key (do it only once):</p>
<pre>$ heroku keys:add
</pre>
<p>You'll be prompted for your username and password the first time you run a heroku command; they'll be saved on ~/.heroku/credentials so you won't be prompted on future runs. It will also upload your public key to allow you to push and pull code.</p>

<p>In order for Heroku to know what to do with your Rack app, create a <code>config.ru</code> (ru stands for Rack up) in the <code>rackheroku</code> folder. The contents are:</p>
<pre>require './my_app'
run MyApp.new
</pre>

<p>Also, copy the <code>my_app.rb</code> file to the <code>rackheroku</code> folder. It's contents are:</p>
<pre># my_app.rb
class MyApp
  def call env
    [200, {"Content-Type" => "text/html"}, ["Hello Rack Participants"]]
  end
end
</pre>

<p>In the already open command window, we will install bundler. Type:</p>
<pre>gem install bundler
</pre>

<p>Close the command window. Next, we will install the required gems (if any) via bundler. In the already open Git Bash shell for folder <code>rackheroku</code> type:</p>
<pre>$ bundle init
Writing new Gemfile to c:/rackheroku/Gemfile
</pre>

<p>Edit the created <code>Gemfile</code> with your preferred text editor to let it look like this:</p>
<pre>source "http://rubygems.org"
gem 'rack'
</pre>

<p>Now we need to tell Bundler to check if we're missing the gems our application depends on, if so, tell it to install them. In your open Bash shell type:</p>
<pre>$ bundle check
The Gemfile's dependencies are satisfied
</pre>

<p>Finally in the open Bash shell, type:</p>
<pre>$ bundle install
</pre>

<p>This will ensure all gems specified on Gemfile, together with their dependencies, are available for your application. Running "bundle install" will also generate a "Gemfile.lock" file. The Gemfile.lock ensures that your deployed versions of gems on Heroku match the version installed locally on your development machine.</p>

<p>Next we set up our local app to use Git. Type:</p>
<pre>$ git init
$ git add .
$ git commit -m "Rack app first commit"
</pre>

<p>Let's create our Rack app on Heroku. Type:</p>
<pre>$ heroku create
Creating quiet-winter-3741... done, stack is bamboo-mri-1.9.2
http://quiet-winter-3741.heroku.com/ | git@heroku.com:quiet-winter-3741.git
Git remote heroku added
</pre>

<p>The app has been created and two URLs are provided. One is for the web face of your new app i.e. http://quiet-winter-3741.heroku.com/ If you visit that URL now, you'll see a standard welcome page, until you push your application up. The other one is for the Git repository that you will push your code to. Normally you would need to add this as a git remote; the "heroku create" command has done this for you automatically. Do note that the output from the create command <em>will be different for each one of you</em>.</p>

<p>Now let us deploy our code to Heroku. Type:</p>
<pre>git push heroku master
</pre>

<p>At this stage we can rename our app to rackheroku. Type:</p>
<pre>$ heroku rename rackheroku
http://rackheroku.heroku.com/ | git@heroku.com:rackheroku.git
Git remote heroku updated
</pre>

<p>Our app is now deployed to Heroku. Open a new browser window and type <a href="http://rackheroku.heroku.com/">http://rackheroku.heroku.com/</a></p>

<p>In the browser window, you should see:</p>
<pre>Hello Rack Participants from across the globe
</pre>

<h2>Deploying a static webpage to Heroku</h2>

<p>We have already created a simple webpage before and the related files are in the folders as shown below:</p>

<pre>- DosaSite
  |- config.ru
  |- public
    |- index.html
    |- stylesheets
    |- images
</pre>

<p>In <code>config.ru</code> file add the following:</p>
<pre>use Rack::Static,
  :urls => ["/stylesheets", "/images"],
  :root => "public"

run lambda { |env|
  [
    200,
    {
      'Content-Type'  => 'text/html',
      'Cache-Control' => 'public, max-age=86400'
    },
    File.open('public/index.html', File::RDONLY)
  ]
}
</pre>

<p>This assumes that your template uses relative references to the images and stylesheets.</p>

<p>All Heroku apps are fronted by <code>Varnish</code>, an HTTP Accelerator, and we should take advantage of it. You may have noticed in the <code>config.ru</code> file we set the <code>Cache-Control</code> header to 86400 seconds (24 hours). This tells the accelerator to go ahead and cache the page. The accelerator already caches any <code>Rack::File</code> for 12 hours as well meaning all your stylesheets and images will also be cached.</p>

<p>Open a Bash shell in the folder <code>DosaSite</code> and type:</p>
<pre>$ git add .
$ git commit -m "first commit to Heroku"
</pre>

<p>Let's create our Rack app on Heroku. Type:</p>
<pre>$ heroku create
Creating falling-fire-2394... done, stack is bamboo-mri-1.9.2
http://falling-fire-2394.heroku.com/ | git@heroku.com:falling-fire-2394.git
Git remote heroku added
</pre>

<p>Now let us deploy our code to Heroku. Type:</p>
<pre>$ git push heroku master
</pre>

<p>At this stage we can rename our app to <code>dosasite</code>. Type:
<pre>$ heroku rename dosasite
http://dosasite.heroku.com/ | git@heroku.com:dosasite.git
Git remote heroku updated
</pre>

<p>Our app is now deployed to Heroku. Open a new browser window and type <a href="http://dosasite.heroku.com/">http://dosasite.heroku.com/</a>. You should see our simple webpage.</p>


<h2>What's JSON?</h2>
<p>JSON stands for <b>J</b>ava<b>S</b>cript <b>O</b>bject <b>N</b>otation. JSON is syntax for storing and exchanging text information, much like XML. JSON is smaller than XML, and faster and easier to parse. JSON is language independent.</p>
<pre>{
"employees": [
{ "firstName":"John" , "lastName":"Doe" },
{ "firstName":"Anna" , "lastName":"Smith" },
{ "firstName":"Peter" , "lastName":"Jones" }
]
}
</pre>
<p>The employee object is an array of 3 employee records (objects).</p>

<p>JSON data is written as name/value pairs. A name/value pair consists of a field name (in double quotes), followed by a colon, followed by a value:</p>
<pre>"firstName" : "Satish"
</pre>

<p>JSON values can be:</p>
<ul>
<li>A number (integer or floating point)</li>
<li>A string (in double quotes)</li>
<li>A Boolean (true or false)</li>
<li>An array (in square brackets)</li>
<li>An object (in curly bractes)</li>
<li>null</li>
</ul>

<p>JSON objects are written inside curly brackets, Objects can contain multiple name/values pairs:</p>
<pre>{ "firstName":"Satish" , "lastName":"Talim" }
</pre>
<p>We will come across JSON, when we study MongoDB next.</p>


<h2>Using MongoDB with Ruby Mongo driver</h2>
<h3>What's NoSQL?</h3>
<p>In the words of <a href="http://openmymind.net/about.html">Karl Seguin</a>:</p>
<blockquote><p>NoSQL is a broad term that means different things to different people. Personally, I use it very broadly to mean a system that plays a part in the storage of data. Put another way, NoSQL (again, for me), is the belief that your persistence layer isn't necessarily the responsibility of a single system. Where relational database vendors have historically tried to position their software as a one-size-fits-all solution, NoSQL leans towards smaller units of responsibility where the best tool for a given job can be leveraged. So, your NoSQL stack might still leverage a relational databases, say MySQL, but it'll also contain Redis as a persistence lookup for specific parts of the system as well as Hadoop for your intensive data processing. Put simply, NoSQL is about being open and aware of alternative, existing and additional patterns and tools for managing your data.<br /><br />You might be wondering where MongoDB fits into all of this. As a <em>document-oriented database</em>, Mongo is a more generalized NoSQL solution. It should be viewed as an alternative to relational databases. Like relational databases, it too can benefit from being paired with some of the more specialized NoSQL solutions.</p></blockquote>

<h3>What's MongoDB?</h3>
<p>MongoDB is a high-performance, open source, schema-free, document-oriented database written in C++.</p>

<h3>Setup MongoDB</h3>

<ul>
<li>Download the binaries from the first row (the recommended stable version) for your operating system of choice from the <a href="">official download page</a>.</li>
<li>Extract the archive (wherever you want) and navigate to the <code>bin</code> subfolder. Don't execute anything just yet, but know that <code>mongod</code> is the server process and <code>mongo</code> is the client shell - these are the two executables we'll be spending most of our time with.</li>
<li>Create a new text file in the <code>bin</code> subfolder named <code>mongodb.config</code></li>
<li>Add a single line to your <code>mongodb.config</code>: <code>dbpath=PATH_TO_WHERE_YOU_WANT_TO_STORE_YOUR_DATABASE_FILES</code>. For example, on Windows you might do <code>dbpath=c:\mongodb\data</code> and on Linux you might do <code>dbpath=/etc/mongodb/data</code>.</li>
<li><em>Make sure the dbpath you specified exists</em></li>
<li>Do add the <code>bin</code> folder to your <code>path</code>. MacOSX and Linux users can follow almost identical directions. The only thing you should have to change are the paths.</li>
<li>Open a new command window and launch <code>mongod</code> with the <code>--config /path/to/your/mongodb.config</code> parameter. On my machine it is: <code>mongod --config c:/mongodb-win32-i386-2.0.1/bin/mongodb.config</code></li>
</ul>

<p>You now have MonogDB up and running. Open another command window and launch <code>mongo</code> (without the d) which will connect a shell to your running server. Try entering <code>db.version()</code> to make sure everything's working as it should. Hopefully you'll see the version number you installed.</p>

<p>While the shell is useful to learn as well as being a useful administrative tool, your code will use a MongoDB driver. MongoDB has a <a href="http://www.mongodb.org/display/DOCS/Drivers">number of official drivers</a> for various languages. These drivers can be thought of as the various database drivers you are probably already familiar with. On top of these drivers, the development community has built more language/framework-specific libraries. For example, <a href="https://github.com/jnunemaker/mongomapper">MongoMapper</a> is a Ruby library which is ActiveRecord-friendly. Whether you choose to program directly against the core MongoDB drivers or some higher-level library is up to you.</p>

<h3>MongoDB Core Concepts</h3>
<ol>
<li>MongoDB has the same concept of a '<em>database</em>' with which you are likely already familiar (or a schema for you Oracle folks). Within a MongoDB instance you can have zero or more databases, each acting as high-level containers for everything else.</li>
<li>A database can have zero or more '<em>collections</em>'. A collection shares enough in common with a traditional 'table' that you can safely think of the two as the same thing.</li>
<li>Collections are made up of zero or more '<em>documents</em>'. Again, a document can safely be thought of as a 'row'.</li>
<li>A document is made up of one or more '<em>fields</em>', which you can probably guess are a lot like 'columns'.</li>
<li>'<em>Indexes</em>' in MongoDB function much like their RDBMS counterparts.</li>
<li>'<em>Cursors</em>' are different than the other five concepts but they are important enough. The important thing to understand about cursors is that when you ask MongoDB for data, it returns a cursor, which we can do things to, such as counting or skipping ahead, without actually pulling down data.</li>
</ol>

<p>To recap, MongoDB is made up of databases which contain collections. A collection is made up of documents. Each document is made up of fields. Collections can be indexed, which improves lookup and sorting performance. Finally, when we get data from MongoDB we do so through a cursor whose actual execution is delayed until necessary.</p>

</div>

<div style="width:image 560 px; font-size:80%; text-align:center;"><img src="http://rubylearning.com/images/MongoDB.jpg" alt="MongoDB" width="560" style="padding-bottom:0.5em;" /><br />MongoDB</div>

<div>

<p><b>Note</b>: <em>The core difference between relational databases and document-oriented databases comes from the fact that relational databases define columns at the table level whereas a document-oriented database defines its fields at the document level</em>.</p>

<h3>The Basics</h3>
<p>The <code>mongo</code> shell runs JavaScript. There are some global commands you can execute, like <code>help</code> or <code>exit</code>. Commands that you execute against the current database are executed against the <code>db</code> object, such as <code>db.help()</code> or <code>db.stats()</code>. Commands that you execute against a specific collection are executed against the <code>db.COLLECTION_NAME</code> object, such as <code>db.students.help()</code> or <code>db.students.count()</code>.</p>

<p>Because <code>mongo</code> is a JavaScript shell, if you execute a method and omit the parentheses (), you'll see the method body rather than executing the method. For example, if you enter <code>db.help</code> (without the parentheses), you'll see the internal implementation of the help method.</p>

<h4>Switch databases</h4>
<p>Use the global <code>use</code> method to switch databases. In the <code>mongo</code> window type:</p>
<pre>use rubylearning
switched to db rubylearning
</pre>

<h4>Insert a document</h4>
<p>It doesn't matter that the database doesn't really exist yet. The first collection that we create will also create the actual <code>rubylearning</code> database. Now that you are inside a database, you can start issuing database commands, like <code>db.getCollectionNames()</code>. If you do so, you should get an empty array ([ ]). Since collections are schema-less, we don't explicitly need to create them. We can simply insert a document into a new collection. To do so, use the insert command, supplying it with the document to insert:</p>
<pre>db.students.insert({name: 'Satish', gender: 'm', weight: 74})
</pre>

<p>The above line is executing <code>insert</code> against the <code>students</code> collection, passing it a single argument. Internally MongoDB uses a binary serialized JSON format. Externally, this means that we use JSON a lot, as is the case with our parameters. If we execute <code>db.getCollectionNames()</code> now, we'll actually see two collections: <code>students</code> and <code>system.indexes</code>. <code>system.indexes</code> is created once per database and contains the information on our databases index.</p>

<h4>Use find()</h4>
<p>You can now use the <code>find</code> command against <code>students</code> to return a list of documents:</p>
<pre>db.students.find()
{ "_id" : ObjectId("4ec0e38aadb3865da7f2fd63"), "name" : "Satish", "gender" : "m", "weight" : 74 }
</pre>

<p>Notice that, in addition to the data you specified, there's an <code>_id</code> field. Every document must have a unique <code>_id</code> field. You can either generate one yourself or let MongoDB generate an ObjectId for you. Most of the time you'll probably want to let MongoDB generate it for you. By default, the <code>_id</code> field is indexed - which explains why the system.indexes collection was created. You can look at system.indexes:</p>
<pre>db.system.indexes.find()
{ "v" : 1, "key" : { "_id" : 1 }, "ns" : "rubylearning.students", "name" : "_id_" }
</pre>

<p>What you're seeing is the name of the index, the database and collection it was created against and the fields included in the index.</p>

<p>Now insert a totally different document into <code>students</code>, such as:</p>
<pre>db.students.insert({name: 'Michael', gender: 'm', home: 'Vienna', mentor: true})
</pre>

<p>And, again use find to list the documents.</p>
<pre>db.students.find()
{ "_id" : ObjectId("4ec0e38aadb3865da7f2fd63"), "name" : "Satish", "gender" : "m", "weight" : 74 }
{ "_id" : ObjectId("4ec0e6a0adb3865da7f2fd64"), "name" : "Michael", "gender" : "m", "home" : "Vienna", "mentor" : true }
</pre>

<h4>Removing all documents</h4>
<p>To remove all documents that we have put in the <code>students</code> collection, type:</p>
<pre>db.students.remove()
</pre>

<h4>Query Selectors</h4>
<p>A MongoDB query selector is like the where clause of an SQL statement. As such, you use it when finding, counting, updating and removing documents from collections. A selector is a JSON object, the simplest of which is <code>{}</code> which matches all documents (<code>null</code> works too). If we wanted to find all female students, we could use <code>{gender:'f'}</code>.</p>
<p>Let's insert some documents into our <code>students</code> collection:</p>
<pre>db.students.insert({name: 'Satish', dob: new Date(1955,2,10,23,55), loves: ['ruby','java'], weight: 76, gender: 'm', country: 'india'});
db.students.insert({name: 'Victor', dob: new Date(1960,4,11,13,55), loves: ['ruby','c++'], weight: 67, gender: 'm', country: 'usa'});
db.students.insert({name: 'Michael', dob: new Date(1965,12,1,10,45), loves: ['ruby','clojure'], weight: 65, gender: 'm', country: 'austria'});
db.students.insert({name: 'Satoshi', dob: new Date(1970,1,11,3,55), loves: ['ruby','c'], weight: 65, gender: 'm', country: 'japan'});
db.students.insert({name: 'Sangeeta', dob: new Date(1965,3,11,2,15), loves: ['english','french'], weight: 60, gender: 'f', country: 'india'});
</pre>

<p><code>{field: value}</code> is used to find any documents where field is equal to value. <code>{field1: value1, field2: value2}</code> is how we do an <em>and</em> statement. The special <code>$lt</code>, <code>$lte</code>, <code>$gt</code>, <code>$gte</code> and <code>$ne</code> are used for less than, less than or equal, greater than, greater than or equal and not equal operations. For example, to get all male students that weigh more than 70 kgs, we could do:</p>
<pre>db.students.find({gender: 'm', weight: {$gt: 70}})
{ "_id" : ObjectId("4ec1d27d0af675a4df885ffd"), "name" : "Satish", "dob" : ISODa
te("1955-03-10T18:25:00Z"), "loves" : [ "ruby", "java" ], "weight" : 76, "gender
" : "m", "country" : "india" }
</pre>

<p>The <code>$exists</code> operator is used for matching the presence or absence of a field, for example:</p>
<pre>db.students.find({name: {$exists: false}})
</pre>

<p>If we want to OR rather than AND we use the <code>$or</code> operator and assign it to an array of values we want or'd:</p>
<pre>db.students.find({gender: 'f', $or: [{loves: 'java'}, {loves: 'english'}, {weight: {$lt: 80}}]})
{ "_id" : ObjectId("4ec1d62f0af675a4df886001"), "name" : "Sangeeta", "dob" : ISODate("1965-04-10T20:45:00Z"), "loves" : [ "english", "french" ], "weight" : 60, "gender" : "f", "country" : "india" }
</pre>
<p>The above will return all female students which either love java or english or weigh less than 80 kgs.</p>

<p>So far we have seen three of the four CRUD (create, read, update and delete) operations. Let's now look at <code>update</code>.</p>

<h4>Updating a document</h4>
<p>We already have some documents in our database <code>rubylearning</code>. Satoshi, one of the participants informs us that he has lost weight and is now at 62 kgs. Let's update the document. Type:</p>
<pre>db.students.update({name: 'Satoshi'}, {weight: 62})
</pre>

<p>Now, if we look at the updated document:</p>
<pre>db.students.find({name: 'Satoshi'})
</pre>
<p>You should discover <b>updates first surprise</b>. No document is found because the second parameter we supply is used to replace the original. In other words, the <code>update</code> found a document by name and replaced the entire document with the new document (the 2nd parameter). <em>This is different than how SQL's update command works</em>.</p>

<p>When you want change the value of one, or a few fields, it's best to use MongoDB's <code>$set</code> modifier:</p>
<pre>db.students.update({weight: 62}, {$set: {name: 'Satoshi', dob: new Date(1970,1,11,3,55), loves: ['ruby','c'], gender: 'm', country: 'japan'}})
</pre>

<p>This'll reset the lost fields. It won't overwrite the new weight since we didn't specify it. Now if we execute:</p>
<pre>db.students.find({name: 'Satoshi'})
</pre>
<p>We get the expected result. Therefore, the correct way to have updated the weight in the first place is:</p>
<pre>db.students.update({name: 'Satoshi'}, {$set: {weight: 62}})
</pre>

<p>Now let's learn how to use the MongoDB Ruby Driver with whatever we have learnt so far.</p>

<h3>MongoDB Ruby Driver - mongo</h3>
<h4>Installation</h4>
<p>Since the driver is just a gem, installation is simple:</p>
<pre>gem install mongo
</pre>

<p>There is one more piece to install, <code>bson_ext</code>. Essentially, this is a collection of C extensions used to increase the speed of serialization. While this is optional, I recommend that you install it:</p>
<pre>gem install bson_ext
</pre>

<h4>Using the mongo gem</h4>
<p>Your Ruby program needs the following:</p>
<pre>require 'mongo'
</pre>

<h4>Making a Connection</h4>
<p>A <code>Mongo::Connection</code> instance represents a connection to MongoDB.</p>
<pre>require 'mongo'
conn = Mongo::Connection.new
</pre>

<p>A database doesn't have to exist - if it doesn't, MongoDB will create it for you. The following example shows three ways to connect to the database "rubylearning" on the local machine:</p>
<pre>require 'mongo'
db = Mongo::Connection.new.db("rubylearning")
db = Mongo::Connection.new("localhost").db("rubylearning")
db = Mongo::Connection.new("localhost", 27017).db("rubylearning")
</pre>
<p>Here, localhost and 27017 represents the MongoDB server address and port when connecting. At this point, the <code>db</code> object will be a connection to a MongoDB server for the specified database. Each DB instance uses a separate socket connection to the server.</p>

<p>Let's call our program <code>mongodb1.rb</code>. The code so far:</p>
<pre>require 'mongo'
conn = Mongo::Connection.new
db = conn.db("rubylearning")
</pre>

<h4>Getting a List Of Collections</h4>
<p>Each database has zero or more collections. You can retrieve a list of them from the <code>db</code> (and print out any that are there):</p>
<pre>db.collection_names.each { |name| puts name }
</pre>

<p>It displays:</p>
<pre>students
system.indexes
</pre>

<h4>Getting a Collection</h4>
<p>You can get a collection to use using the <code>collection</code> method:</p>
<pre>coll = db.collection("students")
</pre>

<p>Once you have this collection object, you can now do things like insert data, query for data, etc.</p>

<h4>Inserting a Document</h4>
<p>MongoDB stores its data as key/value pairs, which maps nicely to Ruby's <code>Hash</code>. Create a hash with our data; insert it into the <code>coll</code> collection; and in return, we receive the <code>ObjectId</code> for the data inserted, from MongoDB.</p>
<pre>doc = {:name => 'Manisha', :dob => Time.now, :loves => ['english','marathi'], :weight => 62, :gender => 'f', :country => 'india'}
coll_id = coll.insert(doc)
</pre>

<h4>Updating a Document</h4>
<p>Using the ObjectId we got back from our <code>insert</code> query, we find that same document again. After changing the data as we see fit, we update the previous document using the <code>update</code> method:</p>
<pre>coll.update( { :_id => coll_id }, '$set' => { :weight => 60 } )
</pre>

<h2>Sinatra with MongoDB</h2>
<h3>What's Sinatra?</h3>

<p>Sinatra keeps a minimal feature set, leaving developers to use the tools that best suit them and their application. Unlike Rails, there's no enforcement of concepts like MVC or REST in Sinatra.</p>

<p>It doesn't assume much about your application, apart from that:</p>
<ul>
<li>it will be written in the Ruby programming language</li>
<li>it will have URLs</li>
</ul>

<p>Sinatra itself provides just a minimal layer on top of the HTTP protocol. Sinatra rides on Rack.</p>

<h3>Create a folder on your hard disk</h3>
<p>Create a folder <code>sinatraapp</code>. This is where we will store our Sinatra app.</p>


<h3>Install Sinatra</h3>
<p>The simplest way to obtain Sinatra is through Rubygems.</p>
<p>In the folder <code>sinatraapp</code>, open a command window and type:</p>
<pre>$ gem install sinatra
</pre>

<p>WIP...</p>

<h2>References</h2>
<ul>
<li><a href="http://rubylearning.com/blog/using-git-github-ebook/">http://rubylearning.com/blog/using-git-github-ebook/</a></li>
<li><a href="http://learningwebdesign.com/">http://learningwebdesign.com/</a></li>
<li><a href="http://www.html-5-tutorial.com/">http://www.html-5-tutorial.com/</a></li>
<li><a href="http://www.w3schools.com/html/html_primary.asp">http://www.w3schools.com/html/html_primary.asp</a></li>
<li><a href="http://www.cssbasics.com/">http://www.cssbasics.com/</a></li>
<li><a href="http://www.w3schools.com/js/">http://www.w3schools.com/js/</a></li>
<li><a href="http://blog.segment7.net/2010/11/15/how-to-name-gems">http://blog.segment7.net/2010/11/15/how-to-name-gems</a></li>
<li><a href="http://rubylearning.com/blog/2010/10/06/gem-sawyer-modern-day-ruby-warrior/">http://rubylearning.com/blog/2010/10/06/gem-sawyer-modern-day-ruby-warrior/</a></li>
<li><a href="http://guides.rubygems.org/make-your-own-gem/">http://guides.rubygems.org/make-your-own-gem/</a></li>
<li><a href="http://devcenter.heroku.com/articles/static-sites-on-heroku">http://devcenter.heroku.com/articles/static-sites-on-heroku</a></li>
<li><a href="http://www.w3schools.com/json/default.asp">http://www.w3schools.com/json/default.asp</a></li>
<li><a href="https://github.com/karlseguin/the-little-mongodb-book">https://github.com/karlseguin/the-little-mongodb-book</a></li>
<li><a href="http://rubylearning.com/blog/2010/12/21/being-awesome-with-the-mongodb-ruby-driver/">http://rubylearning.com/blog/2010/12/21/being-awesome-with-the-mongodb-ruby-driver/</a></li>
<li><a href="http://api.mongodb.org/ruby/current/file.TUTORIAL.html">http://api.mongodb.org/ruby/current/file.TUTORIAL.html</a></li>
</ul>

</div>
</body>
</html>
